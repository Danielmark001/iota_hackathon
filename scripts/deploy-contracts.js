/**
 * IntelliLend Smart Contract Deployment Script
 * 
 * This script deploys the IntelliLend smart contracts to the IOTA EVM network.
 */

const { ethers } = require('ethers');
const fs = require('fs');
const path = require('path');
const dotenv = require('dotenv');

// Load environment variables
dotenv.config();

// Contract compilation paths (would normally come from Hardhat or Truffle)
const BRIDGE_ARTIFACT_PATH = path.join(__dirname, '..', 'artifacts', 'CrossLayerBridge.json');
const LENDING_POOL_ARTIFACT_PATH = path.join(__dirname, '..', 'artifacts', 'LendingPool.json');

// Mock artifacts for demonstration (in a real project, these would be generated by the build process)
const mockBridgeArtifact = {
  abi: [
    "function sendMessageToL1(bytes32 targetAddress, string calldata messageType, bytes calldata payload, uint256 gasLimit) external payable returns (bytes32)",
    "function getMessageIdsBySender(address sender) external view returns (bytes32[] memory)",
    "function messages(bytes32 messageId) external view returns (bytes32, address, bytes32, bytes, uint256, uint8, uint8, string, uint256, uint256)"
  ],
  bytecode: "0x608060405234801561001057600080fd5b50610a3c806100206000396000f3fe60806040..."
};

const mockLendingPoolArtifact = {
  abi: [
    "function deposits(address user) external view returns (uint256)",
    "function borrows(address user) external view returns (uint256)",
    "function collaterals(address user) external view returns (uint256)",
    "function riskScores(address user) external view returns (uint256)",
    "function calculateInterestRate(address user) external view returns (uint256)",
    "function getHealthFactor(address user) external view returns (uint256)",
    "function updateRiskScore(address user, uint256 score) external",
    "function deposit(uint256 amount) external",
    "function borrow(uint256 amount) external"
  ],
  bytecode: "0x608060405234801561001057600080fd5b50610c5e806100206000396000f3fe60806040..."
};

/**
 * Deploy the smart contracts to the IOTA EVM network
 */
async function deployContracts() {
  console.log('=============================================');
  console.log('IntelliLend Smart Contract Deployment');
  console.log('=============================================');
  
  try {
    // Validate environment
    if (!process.env.PRIVATE_KEY) {
      throw new Error('PRIVATE_KEY not found in environment variables');
    }
    
    if (!process.env.IOTA_EVM_RPC_URL) {
      throw new Error('IOTA_EVM_RPC_URL not found in environment variables');
    }
    
    // Connect to IOTA EVM network
    const provider = new ethers.providers.JsonRpcProvider(process.env.IOTA_EVM_RPC_URL);
    const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);
    const address = wallet.address;
    
    console.log(`Connected to IOTA EVM network: ${process.env.IOTA_EVM_RPC_URL}`);
    console.log(`Deployer address: ${address}`);
    
    // Check balance
    const balance = await provider.getBalance(address);
    console.log(`Account balance: ${ethers.utils.formatEther(balance)} IOTA`);
    
    if (balance.eq(0)) {
      console.log('Warning: Account has no balance. Smart contract deployment will fail.');
      console.log('Please fund your account before deploying contracts.');
      
      // For IOTA testnet, provide faucet info
      console.log('You can request testnet funds from the IOTA faucet:');
      console.log('https://faucet.chrysalis2.com/');
      
      return;
    }
    
    // Log network information
    const network = await provider.getNetwork();
    console.log(`Network: ${network.name} (Chain ID: ${network.chainId})`);
    
    // Load contract artifacts
    const bridgeArtifact = loadArtifact(BRIDGE_ARTIFACT_PATH, mockBridgeArtifact);
    const lendingPoolArtifact = loadArtifact(LENDING_POOL_ARTIFACT_PATH, mockLendingPoolArtifact);
    
    // 1. Deploy CrossLayerBridge
    console.log('\nDeploying CrossLayerBridge contract...');
    const bridgeFactory = new ethers.ContractFactory(
      bridgeArtifact.abi, 
      bridgeArtifact.bytecode, 
      wallet
    );
    
    const bridgeContract = await bridgeFactory.deploy(address);
    await bridgeContract.deployed();
    
    console.log(`CrossLayerBridge deployed to: ${bridgeContract.address}`);
    
    // 2. Deploy LendingPool
    console.log('\nDeploying LendingPool contract...');
    
    // Mock token addresses for demonstration
    const lendingTokenAddress = "0x0000000000000000000000000000000000000000";
    const collateralTokenAddress = "0x0000000000000000000000000000000000000000";
    
    const lendingPoolFactory = new ethers.ContractFactory(
      lendingPoolArtifact.abi, 
      lendingPoolArtifact.bytecode, 
      wallet
    );
    
    const lendingPoolContract = await lendingPoolFactory.deploy(
      lendingTokenAddress,
      collateralTokenAddress,
      bridgeContract.address
    );
    await lendingPoolContract.deployed();
    
    console.log(`LendingPool deployed to: ${lendingPoolContract.address}`);
    
    // Update .env file with contract addresses
    updateEnvFile({
      BRIDGE_ADDRESS: bridgeContract.address,
      LENDING_POOL_ADDRESS: lendingPoolContract.address
    });
    
    // Save deployment artifacts
    saveDeploymentInfo({
      networkName: network.name,
      chainId: network.chainId,
      deployer: address,
      bridgeAddress: bridgeContract.address,
      lendingPoolAddress: lendingPoolContract.address,
      timestamp: new Date().toISOString()
    });
    
    console.log('\n=============================================');
    console.log('Deployment completed successfully!');
    console.log('=============================================');
    console.log(`Bridge Address: ${bridgeContract.address}`);
    console.log(`LendingPool Address: ${lendingPoolContract.address}`);
    console.log('Updated .env file with contract addresses');
    console.log('=============================================');
    
  } catch (error) {
    console.error('Error deploying contracts:', error);
    process.exit(1);
  }
}

/**
 * Load contract artifact from file or use mock if not found
 */
function loadArtifact(artifactPath, mockArtifact) {
  try {
    if (fs.existsSync(artifactPath)) {
      return JSON.parse(fs.readFileSync(artifactPath, 'utf8'));
    } else {
      console.log(`Artifact not found at ${artifactPath}, using mock artifact for demonstration`);
      return mockArtifact;
    }
  } catch (error) {
    console.log('Error loading artifact, using mock instead:', error.message);
    return mockArtifact;
  }
}

/**
 * Update .env file with new values
 */
function updateEnvFile(updates) {
  const envPath = path.join(__dirname, '..', '.env');
  
  try {
    // Read existing .env file
    let envContent = '';
    if (fs.existsSync(envPath)) {
      envContent = fs.readFileSync(envPath, 'utf8');
    }
    
    // Update values
    for (const [key, value] of Object.entries(updates)) {
      // Check if key exists in .env
      const regex = new RegExp(`^${key}=.*$`, 'm');
      
      if (regex.test(envContent)) {
        // Replace existing value
        envContent = envContent.replace(regex, `${key}=${value}`);
      } else {
        // Add new value
        envContent += `\n${key}=${value}`;
      }
    }
    
    // Write updated .env file
    fs.writeFileSync(envPath, envContent);
    
  } catch (error) {
    console.error('Error updating .env file:', error);
  }
}

/**
 * Save deployment information to a JSON file
 */
function saveDeploymentInfo(deploymentInfo) {
  const deploymentsDir = path.join(__dirname, '..', 'deployments');
  
  // Create deployments directory if it doesn't exist
  if (!fs.existsSync(deploymentsDir)) {
    fs.mkdirSync(deploymentsDir, { recursive: true });
  }
  
  // Create file name based on network and timestamp
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const fileName = `deployment-${deploymentInfo.networkName}-${timestamp}.json`;
  const filePath = path.join(deploymentsDir, fileName);
  
  // Write deployment info to file
  fs.writeFileSync(filePath, JSON.stringify(deploymentInfo, null, 2));
  
  console.log(`Deployment information saved to: ${filePath}`);
}

// Execute the deployment
if (require.main === module) {
  deployContracts()
    .then(() => process.exit(0))
    .catch(error => {
      console.error(error);
      process.exit(1);
    });
}

module.exports = { deployContracts };
